---
/**
 * ImageAbstract--DNA-DoubleHelix
 *
 * A Three.js DNA double helix with:
 * - Two intertwined helical backbone strands
 * - 20-30 base pairs connecting them
 * - Smooth spinning rotation animation
 * - Colorful base pairs (A-T in warm colors, G-C in cool colors)
 *
 * The classic Watson-Crick structure rendered as a glowing particle/sphere visualization.
 */

interface Props {
  /** Container size in CSS units */
  size?: string;
  /** Number of base pairs (default 24) */
  basePairs?: number;
  /** Tilt angle in degrees (0 = vertical, 90 = horizontal) */
  tiltAngle?: number;
  /** Enable rotation animation */
  animate?: boolean;
  /** Rotation speed multiplier */
  rotationSpeed?: number;
  /** Additional CSS classes */
  class?: string;
}

const {
  size = '520px',
  basePairs = 24,
  tiltAngle = 0,
  animate = true,
  rotationSpeed = 0.3,
  class: className = '',
} = Astro.props as Props;

const containerId = `dna-helix-${Math.random().toString(36).slice(2, 9)}`;
---

<div
  id={containerId}
  class:list={['dna-helix-container', className]}
  style={`width: ${size}; height: ${size};`}
  data-base-pairs={basePairs}
  data-tilt-angle={tiltAngle}
  data-animate={animate}
  data-rotation-speed={rotationSpeed}
>
  <canvas class="dna-helix-canvas"></canvas>
</div>

<style>
  .dna-helix-container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
  }

  .dna-helix-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<script>
  import * as THREE from 'three';

  interface HelixConfig {
    basePairs: number;
    tiltAngle: number;  // in radians
    animate: boolean;
    rotationSpeed: number;
  }

  function initDNAHelix(container: HTMLElement) {
    const canvas = container.querySelector('.dna-helix-canvas') as HTMLCanvasElement | null;
    if (!canvas) return;

    // Convert degrees to radians for tilt angle
    const tiltDegrees = parseFloat(container.dataset.tiltAngle || '0');
    const tiltRadians = (tiltDegrees * Math.PI) / 180;

    const config: HelixConfig = {
      basePairs: parseInt(container.dataset.basePairs || '24', 10),
      tiltAngle: tiltRadians,
      animate: container.dataset.animate !== 'false',
      rotationSpeed: parseFloat(container.dataset.rotationSpeed || '0.3'),
    };

    const scene = new THREE.Scene();

    const width = container.clientWidth || 400;
    const height = container.clientHeight || 400;

    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.z = 5;
    camera.position.y = 0.5;

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    const group = new THREE.Group();
    scene.add(group);

    // DNA parameters
    const helixRadius = 0.6;          // Distance from center to backbone
    const helixHeight = 3.5;          // Total height of helix
    const twists = 2.5;               // Number of full rotations
    const backbonePointsPerPair = 8;  // Smoothness of backbone curve

    // Colors - brand palette
    const backboneColor1 = new THREE.Color(0x6643e2); // Marjorelle purple
    const backboneColor2 = new THREE.Color(0x9C85DF); // Lilac

    // Base pair colors (warm = A-T, cool = G-C)
    const basePairColors = [
      0xff5e58, // warm red (A)
      0xffb347, // orange (T)
      0x4dd0e1, // teal (G)
      0x42a5f5, // blue (C)
      0xba68c8, // purple
      0xa7ff83, // mint
    ];

    // Create glowing sphere material
    function createGlowMaterial(color: THREE.Color, opacity = 0.9) {
      return new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
    }

    // Backbone sphere geometry (small)
    const backboneSphereGeom = new THREE.SphereGeometry(0.06, 12, 12);

    // Base pair sphere geometry (larger)
    const baseSphereGeom = new THREE.SphereGeometry(0.08, 12, 12);

    // Connector cylinder geometry
    const connectorGeom = new THREE.CylinderGeometry(0.025, 0.025, 1, 8);

    // Store all meshes for animation
    const backboneMeshes1: THREE.Mesh[] = [];
    const backboneMeshes2: THREE.Mesh[] = [];
    const basePairGroups: THREE.Group[] = [];

    const totalBackbonePoints = config.basePairs * backbonePointsPerPair;

    // Create backbone strands
    for (let i = 0; i <= totalBackbonePoints; i++) {
      const t = i / totalBackbonePoints;
      const angle = t * Math.PI * 2 * twists;
      const y = (t - 0.5) * helixHeight;

      // Strand 1 position
      const x1 = Math.cos(angle) * helixRadius;
      const z1 = Math.sin(angle) * helixRadius;

      // Strand 2 position (opposite side, offset by PI)
      const x2 = Math.cos(angle + Math.PI) * helixRadius;
      const z2 = Math.sin(angle + Math.PI) * helixRadius;

      // Interpolate backbone colors along height
      const colorT = (Math.sin(t * Math.PI * 4) + 1) / 2;
      const color1 = backboneColor1.clone().lerp(backboneColor2, colorT);
      const color2 = backboneColor2.clone().lerp(backboneColor1, colorT);

      // Create backbone spheres
      const sphere1 = new THREE.Mesh(backboneSphereGeom, createGlowMaterial(color1, 0.85));
      sphere1.position.set(x1, y, z1);
      group.add(sphere1);
      backboneMeshes1.push(sphere1);

      const sphere2 = new THREE.Mesh(backboneSphereGeom, createGlowMaterial(color2, 0.85));
      sphere2.position.set(x2, y, z2);
      group.add(sphere2);
      backboneMeshes2.push(sphere2);
    }

    // Create base pairs at regular intervals
    for (let i = 0; i < config.basePairs; i++) {
      const t = (i + 0.5) / config.basePairs;
      const angle = t * Math.PI * 2 * twists;
      const y = (t - 0.5) * helixHeight;

      // Positions of the two backbone points at this height
      const x1 = Math.cos(angle) * helixRadius;
      const z1 = Math.sin(angle) * helixRadius;
      const x2 = Math.cos(angle + Math.PI) * helixRadius;
      const z2 = Math.sin(angle + Math.PI) * helixRadius;

      const basePairGroup = new THREE.Group();
      basePairGroup.position.y = y;

      // Pick colors for this base pair
      const colorIndex1 = i % basePairColors.length;
      const colorIndex2 = (i + 2) % basePairColors.length;
      const baseColor1 = new THREE.Color(basePairColors[colorIndex1]);
      const baseColor2 = new THREE.Color(basePairColors[colorIndex2]);

      // Base sphere 1 (at strand 1)
      const base1 = new THREE.Mesh(baseSphereGeom, createGlowMaterial(baseColor1));
      base1.position.set(x1, 0, z1);
      basePairGroup.add(base1);

      // Base sphere 2 (at strand 2)
      const base2 = new THREE.Mesh(baseSphereGeom, createGlowMaterial(baseColor2));
      base2.position.set(x2, 0, z2);
      basePairGroup.add(base2);

      // Connector between bases (hydrogen bonds)
      const midX = (x1 + x2) / 2;
      const midZ = (z1 + z2) / 2;
      const distance = Math.sqrt((x2 - x1) ** 2 + (z2 - z1) ** 2);

      // Create 2-3 small connector spheres to represent hydrogen bonds
      const numBonds = i % 2 === 0 ? 2 : 3; // A-T has 2, G-C has 3 bonds
      for (let b = 1; b <= numBonds; b++) {
        const bondT = b / (numBonds + 1);
        const bondX = x1 + (x2 - x1) * bondT;
        const bondZ = z1 + (z2 - z1) * bondT;

        const bondSphere = new THREE.Mesh(
          new THREE.SphereGeometry(0.035, 8, 8),
          createGlowMaterial(new THREE.Color(0xffffff), 0.6)
        );
        bondSphere.position.set(bondX, 0, bondZ);
        basePairGroup.add(bondSphere);
      }

      // Thin connector line (using cylinder)
      const connector = new THREE.Mesh(
        connectorGeom,
        new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.25,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        })
      );
      connector.position.set(midX, 0, midZ);
      connector.rotation.z = Math.PI / 2;
      connector.rotation.y = -angle;
      connector.scale.y = distance * 0.9;
      basePairGroup.add(connector);

      group.add(basePairGroup);
      basePairGroups.push(basePairGroup);
    }

    // Center the helix and apply tilt angle
    group.position.y = 0;

    // Apply the base tilt angle (around X axis for a "laying down" effect)
    // Store the base tilt for use in animation
    const baseTiltX = config.tiltAngle;
    group.rotation.x = baseTiltX;

    // Add subtle ambient glow effect using point light
    const pointLight = new THREE.PointLight(0x6643e2, 0.5, 10);
    pointLight.position.set(0, 0, 2);
    scene.add(pointLight);

    // Animation
    let animationId: number;
    let time = 0;

    function animate() {
      animationId = requestAnimationFrame(animate);

      if (config.animate) {
        time += 0.016;

        // Main rotation around Y axis
        group.rotation.y = time * config.rotationSpeed;

        // Subtle wobble added to the base tilt angle
        group.rotation.x = baseTiltX + Math.sin(time * 0.3) * 0.1;
        group.rotation.z = Math.cos(time * 0.25) * 0.05;

        // Pulse the base pair spheres slightly
        basePairGroups.forEach((bpGroup, idx) => {
          const pulsePhase = time * 2 + idx * 0.3;
          const scale = 1 + Math.sin(pulsePhase) * 0.1;
          bpGroup.children.forEach((child) => {
            if (child instanceof THREE.Mesh && child.geometry.type === 'SphereGeometry') {
              child.scale.setScalar(scale);
            }
          });
        });

        // Subtle backbone pulse
        const backbonePulse = 1 + Math.sin(time * 1.5) * 0.05;
        backboneMeshes1.forEach((mesh, idx) => {
          const phase = time * 2 + idx * 0.1;
          mesh.scale.setScalar(backbonePulse + Math.sin(phase) * 0.03);
        });
        backboneMeshes2.forEach((mesh, idx) => {
          const phase = time * 2 + idx * 0.1 + Math.PI;
          mesh.scale.setScalar(backbonePulse + Math.sin(phase) * 0.03);
        });
      }

      renderer.render(scene, camera);
    }

    animate();

    // Resize handling
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width > 0 && height > 0) {
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        }
      }
    });
    resizeObserver.observe(container);

    // Cleanup on removal
    const mutationObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((node) => {
          if (node === container || (node as Element).contains?.(container)) {
            cancelAnimationFrame(animationId);
            resizeObserver.disconnect();
            mutationObserver.disconnect();
            backboneSphereGeom.dispose();
            baseSphereGeom.dispose();
            connectorGeom.dispose();
            renderer.dispose();
          }
        });
      });
    });

    if (container.parentElement) {
      mutationObserver.observe(container.parentElement, { childList: true });
    }
  }

  // Lazy loading with IntersectionObserver to manage WebGL contexts
  function setupLazyLoading() {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const container = entry.target as HTMLElement;
          if (entry.isIntersecting) {
            if (container.dataset.initialized !== 'true') {
              initDNAHelix(container);
              container.dataset.initialized = 'true';
            }
          }
        });
      },
      { rootMargin: '100px', threshold: 0 }
    );
    document.querySelectorAll('.dna-helix-container').forEach((c) => observer.observe(c));
    return observer;
  }

  let lazyObserver: IntersectionObserver | null = null;
  document.addEventListener('DOMContentLoaded', () => { lazyObserver = setupLazyLoading(); });
  document.addEventListener('astro:page-load', () => {
    if (lazyObserver) lazyObserver.disconnect();
    lazyObserver = setupLazyLoading();
  });
</script>
