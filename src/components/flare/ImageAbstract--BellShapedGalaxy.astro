---
/**
 * ImageAbstract--BellShapedGalaxy
 *
 * A Three.js particle visualization of a bell-shaped galaxy:
 * - Tubular outer shell with radial spokes
 * - Dense filaments projecting inward
 * - Core region with denser particles
 * - Flowing stellar particles through the center
 *
 * A cosmic bell rendered in particles.
 */

interface Props {
  /** Container size in CSS units */
  size?: string;
  /** Main shell color */
  shellColor?: string;
  /** Filament highlight color */
  filamentColor?: string;
  /** Core particle color */
  coreColor?: string;
  /** Enable flowing animation */
  animate?: boolean;
  /** Animation speed multiplier */
  animationSpeed?: number;
  /** Additional CSS classes */
  class?: string;
}

const {
  size = '520px',
  shellColor = '#e57373',
  filamentColor = '#ffab91',
  coreColor = '#ffe082',
  animate = true,
  animationSpeed = 0.3,
  class: className = '',
} = Astro.props as Props;

const containerId = `bellgalaxy-${Math.random().toString(36).slice(2, 9)}`;
---

<div
  id={containerId}
  class:list={['bellgalaxy-container', className]}
  style={`width: ${size}; height: ${size};`}
  data-shell-color={shellColor}
  data-filament-color={filamentColor}
  data-core-color={coreColor}
  data-animate={animate}
  data-animation-speed={animationSpeed}
>
  <canvas class="bellgalaxy-canvas"></canvas>
</div>

<style>
  .bellgalaxy-container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
  }

  .bellgalaxy-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<script>
  import * as THREE from 'three';

  interface BellGalaxyConfig {
    shellColor: string;
    filamentColor: string;
    coreColor: string;
    animate: boolean;
    animationSpeed: number;
  }

  function initBellGalaxy(container: HTMLElement) {
    const canvas = container.querySelector('.bellgalaxy-canvas') as HTMLCanvasElement | null;
    if (!canvas) return;

    const config: BellGalaxyConfig = {
      shellColor: container.dataset.shellColor || '#e57373',
      filamentColor: container.dataset.filamentColor || '#ffab91',
      coreColor: container.dataset.coreColor || '#ffe082',
      animate: container.dataset.animate !== 'false',
      animationSpeed: parseFloat(container.dataset.animationSpeed || '0.3'),
    };

    const scene = new THREE.Scene();

    const width = container.clientWidth || 520;
    const height = container.clientHeight || 520;

    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.set(0, 0, 3.5);

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    const group = new THREE.Group();
    scene.add(group);

    // Gut segment parameters
    const tubeRadius = 1.2;
    const tubeLength = 2.5;
    const villiCount = 180;
    const villiHeight = 0.25;

    // Particle arrays
    const positions: number[] = [];
    const sizes: number[] = [];
    const colors: number[] = [];
    const alphas: number[] = [];

    const shellCol = new THREE.Color(config.shellColor);
    const filamentCol = new THREE.Color(config.filamentColor);
    const coreCol = new THREE.Color(config.coreColor);

    // Villi data structure
    interface Villus {
      basePos: THREE.Vector3;
      dir: THREE.Vector3;
      length: number;
      width: number;
    }

    const villi: Villus[] = [];

    /**
     * Generate villi positions on inner tube surface
     */
    function generateVilliStructure() {
      for (let i = 0; i < villiCount; i++) {
        // Position along tube and around circumference
        const z = (Math.random() - 0.5) * tubeLength * 0.85;
        const theta = Math.random() * Math.PI * 2;

        // Base position on inner tube surface
        const baseX = Math.cos(theta) * tubeRadius * 0.9;
        const baseY = Math.sin(theta) * tubeRadius * 0.9;

        const basePos = new THREE.Vector3(baseX, baseY, z);

        // Direction points inward toward tube center
        const dir = new THREE.Vector3(-Math.cos(theta), -Math.sin(theta), 0);
        // Add some randomness for organic feel
        dir.x += (Math.random() - 0.5) * 0.3;
        dir.y += (Math.random() - 0.5) * 0.3;
        dir.z += (Math.random() - 0.5) * 0.15;
        dir.normalize();

        villi.push({
          basePos,
          dir,
          length: villiHeight * (0.7 + Math.random() * 0.6),
          width: 0.04 + Math.random() * 0.03,
        });
      }
    }

    generateVilliStructure();

    /**
     * Generate the tube wall (outer layer seen from inside)
     */
    function generateTubeWall() {
      const wallParticles = 8000;

      for (let i = 0; i < wallParticles; i++) {
        const z = (Math.random() - 0.5) * tubeLength;
        const theta = Math.random() * Math.PI * 2;

        // Radial variation for thickness
        const rVariation = 0.85 + Math.random() * 0.15;
        const r = tubeRadius * rVariation;

        const x = Math.cos(theta) * r;
        const y = Math.sin(theta) * r;

        positions.push(x, y, z);

        // Size
        const baseSize = 0.015 + Math.random() * 0.012;
        sizes.push(baseSize);

        // Darker in deeper tissue
        const depthFactor = (r - tubeRadius * 0.85) / (tubeRadius * 0.15);
        const colorMix = depthFactor * 0.4;
        const particleColor = shellCol.clone().lerp(filamentCol, colorMix);
        colors.push(particleColor.r, particleColor.g, particleColor.b);

        alphas.push(0.5 + depthFactor * 0.3);
      }
    }

    /**
     * Generate villi (finger-like projections)
     */
    function generateVilli() {
      const particlesPerVillus = 120;

      for (const villus of villi) {
        for (let i = 0; i < particlesPerVillus; i++) {
          // Position along villus (0 = base, 1 = tip)
          const t = Math.pow(Math.random(), 0.6);

          // Position along villus length
          const alongVillus = t * villus.length;

          // Radius tapers toward tip (bulbous finger shape)
          const taperFactor = Math.sin((1 - t * 0.8) * Math.PI * 0.5);
          const villRadius = villus.width * taperFactor;

          // Random position within cross-section
          const angle = Math.random() * Math.PI * 2;
          const r = Math.sqrt(Math.random()) * villRadius;

          // Create perpendicular vectors
          const up = Math.abs(villus.dir.y) < 0.9
            ? new THREE.Vector3(0, 1, 0)
            : new THREE.Vector3(1, 0, 0);
          const perp1 = new THREE.Vector3().crossVectors(villus.dir, up).normalize();
          const perp2 = new THREE.Vector3().crossVectors(villus.dir, perp1).normalize();

          // Final position
          const x = villus.basePos.x + villus.dir.x * alongVillus +
                    perp1.x * Math.cos(angle) * r + perp2.x * Math.sin(angle) * r;
          const y = villus.basePos.y + villus.dir.y * alongVillus +
                    perp1.y * Math.cos(angle) * r + perp2.y * Math.sin(angle) * r;
          const z = villus.basePos.z + villus.dir.z * alongVillus +
                    perp1.z * Math.cos(angle) * r + perp2.z * Math.sin(angle) * r;

          positions.push(x, y, z);

          // Larger at tips for visibility
          const tipBonus = t > 0.6 ? 1.3 : 1.0;
          sizes.push((0.018 + Math.random() * 0.014) * tipBonus);

          // Lighter toward tips
          const colorMix = 0.3 + t * 0.5;
          const particleColor = shellCol.clone().lerp(filamentCol, colorMix);
          colors.push(particleColor.r, particleColor.g, particleColor.b);

          alphas.push(0.75 + t * 0.25);
        }
      }
    }

    /**
     * Generate crypts (spaces between villi bases)
     */
    function generateCrypts() {
      const cryptParticles = 3000;

      for (let i = 0; i < cryptParticles; i++) {
        const z = (Math.random() - 0.5) * tubeLength * 0.85;
        const theta = Math.random() * Math.PI * 2;

        // Position at base layer between villi
        const r = tubeRadius * (0.88 + Math.random() * 0.04);

        const x = Math.cos(theta) * r;
        const y = Math.sin(theta) * r;

        positions.push(x, y, z);

        // Smaller, denser particles
        sizes.push(0.012 + Math.random() * 0.008);

        // Darker color in crypts
        const darkerShell = shellCol.clone().multiplyScalar(0.7);
        colors.push(darkerShell.r, darkerShell.g, darkerShell.b);

        alphas.push(0.6 + Math.random() * 0.2);
      }
    }

    /**
     * Generate flowing nutrient particles (in the lumen)
     */
    function generateNutrients() {
      const nutrientParticles = 800;

      for (let i = 0; i < nutrientParticles; i++) {
        // Position in the central lumen (inner space)
        const z = (Math.random() - 0.5) * tubeLength;
        const theta = Math.random() * Math.PI * 2;
        const r = Math.random() * tubeRadius * 0.5; // Inner half

        const x = Math.cos(theta) * r;
        const y = Math.sin(theta) * r;

        positions.push(x, y, z);

        // Varied sizes
        sizes.push(0.02 + Math.random() * 0.025);

        // Golden nutrient color with variation
        const variation = 0.8 + Math.random() * 0.4;
        const particleColor = coreCol.clone().multiplyScalar(variation);
        colors.push(particleColor.r, particleColor.g, particleColor.b);

        alphas.push(0.4 + Math.random() * 0.4);
      }
    }

    // Generate all particles
    generateTubeWall();
    generateVilli();
    generateCrypts();
    generateNutrients();

    // Store initial positions for animation
    const initialPositions = new Float32Array(positions);

    // Create geometry
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('alpha', new THREE.Float32BufferAttribute(alphas, 1));

    const material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
      },
      vertexShader: `
        attribute float size;
        attribute float alpha;
        attribute vec3 color;
        varying float vAlpha;
        varying vec3 vColor;
        uniform float time;

        void main() {
          vec3 pos = position;

          // Subtle peristaltic wave along z-axis
          float wave = sin(time * 0.5 + pos.z * 2.0) * 0.02;
          float radial = length(pos.xy);

          // Only affect tube wall (not inner particles)
          if (radial > 0.6) {
            pos.x += pos.x / radial * wave;
            pos.y += pos.y / radial * wave;
          }

          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          gl_PointSize = size * 380.0 * (1.0 / -mvPosition.z);

          float depthFade = smoothstep(6.0, 2.5, -mvPosition.z);
          vAlpha = alpha * depthFade;
          vColor = color;
        }
      `,
      fragmentShader: `
        varying float vAlpha;
        varying vec3 vColor;

        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);

          float coreFalloff = 1.0 - smoothstep(0.0, 0.25, dist);
          float glowFalloff = 1.0 - smoothstep(0.1, 0.5, dist);

          float alpha = mix(glowFalloff * 0.5, coreFalloff, 0.65);
          alpha *= vAlpha;

          if (alpha < 0.01) discard;

          vec3 finalColor = vColor * (1.1 + coreFalloff * 0.3);

          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });

    const particles = new THREE.Points(geometry, material);
    group.add(particles);

    // Store nutrient particle range for animation
    const wallCount = 8000;
    const villiCount2 = villi.length * 120;
    const cryptCount = 3000;
    const nutrientStart = wallCount + villiCount2 + cryptCount;
    const nutrientCount = 800;

    // Animation
    let animationId: number;
    let time = 0;

    function animate() {
      animationId = requestAnimationFrame(animate);

      if (config.animate) {
        time += 0.016 * config.animationSpeed;

        // Update shader time
        (material.uniforms.time as any).value = time;

        // Animate nutrient particles flowing
        const posArray = geometry.attributes.position.array as Float32Array;

        for (let i = nutrientStart; i < nutrientStart + nutrientCount; i++) {
          const idx = i * 3;

          // Flow along z-axis with some drift
          let z = initialPositions[idx + 2] + time * 0.3;

          // Wrap around when past tube length
          const halfLength = tubeLength / 2;
          if (z > halfLength) {
            z -= tubeLength;
          }

          // Slight radial drift
          const x = initialPositions[idx] + Math.sin(time * 0.5 + i * 0.1) * 0.03;
          const y = initialPositions[idx + 1] + Math.cos(time * 0.4 + i * 0.15) * 0.03;

          posArray[idx] = x;
          posArray[idx + 1] = y;
          posArray[idx + 2] = z;
        }

        geometry.attributes.position.needsUpdate = true;

        // Slow rotation to show different angles
        group.rotation.x = Math.PI * 0.15 + Math.sin(time * 0.1) * 0.1;
        group.rotation.y = time * 0.05;
        group.rotation.z = Math.sin(time * 0.08) * 0.05;
      }

      renderer.render(scene, camera);
    }

    animate();

    // Resize handling
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width > 0 && height > 0) {
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        }
      }
    });
    resizeObserver.observe(container);

    // Cleanup
    const mutationObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((node) => {
          if (node === container || (node as Element).contains?.(container)) {
            cancelAnimationFrame(animationId);
            resizeObserver.disconnect();
            mutationObserver.disconnect();
            geometry.dispose();
            material.dispose();
            renderer.dispose();
          }
        });
      });
    });

    if (container.parentElement) {
      mutationObserver.observe(container.parentElement, { childList: true });
    }
  }

  // Lazy loading
  function setupLazyLoading() {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const container = entry.target as HTMLElement;
          if (entry.isIntersecting) {
            if (container.dataset.initialized !== 'true') {
              initBellGalaxy(container);
              container.dataset.initialized = 'true';
            }
          }
        });
      },
      { rootMargin: '100px', threshold: 0 }
    );
    document.querySelectorAll('.bellgalaxy-container').forEach((c) => observer.observe(c));
    return observer;
  }

  let lazyObserver: IntersectionObserver | null = null;
  document.addEventListener('DOMContentLoaded', () => { lazyObserver = setupLazyLoading(); });
  document.addEventListener('astro:page-load', () => {
    if (lazyObserver) lazyObserver.disconnect();
    lazyObserver = setupLazyLoading();
  });
</script>
