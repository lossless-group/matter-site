---
/**
 * ImageAbstract--HumanBody--Particles
 *
 * A Three.js particle field creating a realistic human upper-body silhouette
 * with artistic particle distribution matching the reference image style.
 *
 * Design:
 * - Anatomically-inspired silhouette with organic curves
 * - Very dense, bright particles at the head (glowing effect)
 * - Gradual density falloff toward the torso
 * - Realistic shoulder/clavicle contours
 * - Subtle 3D depth with particle size/opacity variation
 */

interface Props {
  /** Container size in pixels or CSS units */
  size?: string;
  /** Particle color - can be hex, CSS variable name, or 'auto' to use --fx-orb-color */
  color?: string;
  /** Enable animation */
  animate?: boolean;
  /** Rotation speed multiplier */
  rotationSpeed?: number;
  /** Additional CSS classes */
  class?: string;
}

const {
  size = '520px',
  color = 'auto',
  animate = true,
  rotationSpeed = 0.15,
  class: className = '',
} = Astro.props as Props;

const containerId = `human-body-${Math.random().toString(36).slice(2, 9)}`;
---

<div
  id={containerId}
  class:list={['human-body-container', className]}
  style={`width: ${size}; height: ${size};`}
  data-color={color}
  data-animate={animate}
  data-rotation-speed={rotationSpeed}
>
  <canvas class="human-body-canvas"></canvas>
</div>

<style>
  .human-body-container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
  }

  .human-body-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<script>
  import * as THREE from 'three';

  interface HumanBodyConfig {
    color: string;
    animate: boolean;
    rotationSpeed: number;
  }

  /**
   * Get color - either from explicit prop or from CSS variable
   */
  function getBodyColor(container: HTMLElement): string {
    const colorProp = container.dataset.color || 'auto';

    if (colorProp === 'auto') {
      const computedStyle = getComputedStyle(document.documentElement);
      const cssColor = computedStyle.getPropertyValue('--fx-orb-color').trim();
      return cssColor || '#ffffff';
    }

    return colorProp;
  }

  function initHumanBody(container: HTMLElement) {
    const canvas = container.querySelector('.human-body-canvas') as HTMLCanvasElement | null;
    if (!canvas) return;

    const config: HumanBodyConfig = {
      color: getBodyColor(container),
      animate: container.dataset.animate !== 'false',
      rotationSpeed: parseFloat(container.dataset.rotationSpeed || '0.15'),
    };

    const scene = new THREE.Scene();

    const width = container.clientWidth || 400;
    const height = container.clientHeight || 400;

    const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 1000);
    camera.position.z = 3.2;

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    // Reduced particle count for larger, more spaced particles
    const particleCount = 18000;
    const positions = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);
    const alphas = new Float32Array(particleCount);

    let count = 0;

    /**
     * Sophisticated body silhouette using spline-like width functions
     * for organic, anatomically-inspired curves.
     * Coordinate system: x in [-1, 1], y in [0, 1] (bottom to top)
     */
    function getBodyWidth(y: number): number {
      // Head (y: 0.75 - 1.0) - narrower, more natural oval
      if (y >= 0.75) {
        const headY = (y - 0.75) / 0.25; // 0 at jaw, 1 at crown
        // Ellipse centered slightly above middle for skull shape
        const centerY = 0.55;
        const normalizedY = (headY - centerY) / 0.50;

        // Clamp to avoid sqrt of negative
        const ellipseFactor = Math.max(0, 1 - normalizedY * normalizedY);
        // Narrower head width (was 0.17)
        const headWidth = 0.13 * Math.sqrt(ellipseFactor);

        // Taper more at chin/jaw - narrower jawline
        if (headY < 0.2) {
          return headWidth * (0.6 + headY * 1.5);
        }
        return headWidth;
      }

      // Neck (y: 0.68 - 0.75) - natural neck, connects smoothly to jaw
      if (y >= 0.68) {
        const neckT = (y - 0.68) / 0.07;
        // Neck is narrow, widens slightly toward jaw
        // Use curve for organic feel, not linear
        const neckBase = 0.055;
        const jawWidth = 0.08; // Must match where head tapers to
        const t = neckT * neckT; // Ease in
        return neckBase + (jawWidth - neckBase) * t;
      }

      // Trapezius / neck-to-shoulder slope (y: 0.54 - 0.68)
      // This is the key area - smooth organic curve, no "popped collar"
      if (y >= 0.54) {
        const trapT = (y - 0.54) / 0.14;
        const neckWidth = 0.055;
        const shoulderWidth = 0.36;
        // Smoother curve - cubic ease for natural trapezius slope
        const t = trapT * trapT * trapT; // More gradual at bottom
        return shoulderWidth + (neckWidth - shoulderWidth) * t;
      }

      // Shoulders / deltoids (y: 0.46 - 0.54)
      if (y >= 0.46) {
        const shoulderT = (y - 0.46) / 0.08;
        // Shoulders curve naturally
        const baseWidth = 0.36 - shoulderT * 0.02;
        return baseWidth;
      }

      // Upper chest / pectorals (y: 0.32 - 0.46)
      if (y >= 0.32) {
        const chestT = (y - 0.32) / 0.14;
        // Slight chest curve
        return 0.32 - chestT * 0.04;
      }

      // Mid torso (y: 0.18 - 0.32)
      if (y >= 0.18) {
        const midT = (y - 0.18) / 0.14;
        // Taper toward waist
        return 0.26 - midT * 0.06;
      }

      // Lower torso / waist (y: 0.0 - 0.18)
      const lowerT = y / 0.18;
      // Gradual fade-out at bottom
      return 0.20 * lowerT;
    }

    /**
     * Check if point is inside body silhouette with edge softness
     */
    function inBody(x: number, y: number): { inside: boolean; edgeDist: number } {
      const width = getBodyWidth(y);
      const absX = Math.abs(x);

      if (absX > width) {
        return { inside: false, edgeDist: 0 };
      }

      // Calculate distance from edge (0 = at edge, 1 = at center)
      const edgeDist = 1 - (absX / width);
      return { inside: true, edgeDist };
    }

    /**
     * Add anatomical detail: shoulder curve indentation
     */
    function shoulderCurveAdjustment(x: number, y: number): number {
      // Create the deltoid/arm cutout curve on each side
      if (y >= 0.35 && y <= 0.54) {
        const absX = Math.abs(x);
        if (absX > 0.26) {
          // Curve inward at the outer shoulders
          const t = (y - 0.35) / 0.19;
          const curveDepth = 0.07 * Math.sin(t * Math.PI);
          if (absX > 0.36 - curveDepth) {
            return -1; // Outside
          }
        }
      }
      return 0;
    }

    const maxTries = particleCount * 8;
    let tries = 0;

    while (count < particleCount && tries < maxTries) {
      tries++;

      // Sample in body bounds
      const x = (Math.random() - 0.5) * 0.9;
      const y = Math.random();

      const bodyCheck = inBody(x, y);
      if (!bodyCheck.inside) continue;

      // Check shoulder curve adjustment
      if (shoulderCurveAdjustment(x, y) < 0) continue;

      // Density varies by region - reduced overall for more spacing
      let density = 0.4;

      // Head is dense (glowing head effect)
      if (y >= 0.75) {
        density = 0.85;
      }
      // Upper body moderately dense
      else if (y >= 0.46) {
        density = 0.35 + (y - 0.46) * 1.2;
      }
      // Lower body sparser
      else {
        density = 0.12 + y * 0.4;
      }

      // Edge particles are sparser for soft silhouette edge
      density *= 0.35 + bodyCheck.edgeDist * 0.65;

      if (Math.random() > density) continue;

      // Map to 3D coordinates
      const px = x * 2.5;
      const py = (y - 0.5) * 2.2; // Center vertically (head at top, torso below)

      // Z depth: more depth in torso, flatter head
      let zRange = 0.15;
      if (y >= 0.75) {
        zRange = 0.25; // Head has more 3D roundness
      } else if (y >= 0.46) {
        zRange = 0.20;
      }
      const pz = (Math.random() - 0.5) * zRange;

      const baseIndex = count * 3;
      positions[baseIndex] = px;
      positions[baseIndex + 1] = py;
      positions[baseIndex + 2] = pz;

      // Size varies: larger/brighter in head, smaller scattered in torso
      // Larger particles for more visual impact (25% increase)
      let sizeBase = 0.018 + Math.random() * 0.015;

      if (y >= 0.75) {
        // Head particles: bright, varied sizes for glowing effect
        sizeBase = 0.016 + Math.random() * 0.024;
        // Some larger "star" particles
        if (Math.random() < 0.2) {
          sizeBase *= 1.7;
        }
      } else if (y >= 0.5) {
        sizeBase = 0.017 + Math.random() * 0.018;
      } else {
        // Lower torso: sparser, more varied
        sizeBase = 0.014 + Math.random() * 0.020;
        if (Math.random() < 0.12) {
          sizeBase *= 2.2;
        }
      }

      sizes[count] = sizeBase;

      // Alpha varies for depth and glow effect
      let alpha = 0.6 + Math.random() * 0.4;
      if (y >= 0.75) {
        // Head is brighter
        alpha = 0.8 + Math.random() * 0.2;
      }
      // Fade edges
      alpha *= 0.5 + bodyCheck.edgeDist * 0.5;

      alphas[count] = alpha;
      count++;
    }

    const posTrimmed = positions.subarray(0, count * 3);
    const sizeTrimmed = sizes.subarray(0, count);
    const alphaTrimmed = alphas.subarray(0, count);

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(posTrimmed, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizeTrimmed, 1));
    geometry.setAttribute('alpha', new THREE.BufferAttribute(alphaTrimmed, 1));

    const material = new THREE.ShaderMaterial({
      uniforms: {
        color: { value: new THREE.Color(config.color) },
      },
      vertexShader: `
        attribute float size;
        attribute float alpha;
        varying float vAlpha;
        varying float vSize;

        void main() {
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          // Size attenuation - larger multiplier for bolder, more visible particles
          gl_PointSize = size * 600.0 * (1.0 / -mvPosition.z);

          // Pass alpha with depth-based adjustment
          float depthFade = smoothstep(5.0, 2.0, -mvPosition.z);
          vAlpha = alpha * depthFade;
          vSize = size;
        }
      `,
      fragmentShader: `
        uniform vec3 color;
        varying float vAlpha;
        varying float vSize;

        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);

          // Soft circular particle with bright glow
          float coreFalloff = 1.0 - smoothstep(0.0, 0.3, dist);
          float glowFalloff = 1.0 - smoothstep(0.15, 0.5, dist);

          float alpha = mix(glowFalloff * 0.7, coreFalloff, 0.65);
          alpha *= vAlpha;

          if (alpha < 0.005) discard;

          // Boosted color for more vibrancy - brighter core
          vec3 finalColor = color * (1.1 + coreFalloff * 0.4);

          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    let animationId: number;
    let time = 0;

    function animate() {
      animationId = requestAnimationFrame(animate);

      if (config.animate) {
        time += 0.016;
        // Very subtle, slow oscillation
        points.rotation.y = Math.sin(time * 0.15) * config.rotationSpeed * 0.4;
        points.rotation.x = Math.sin(time * 0.1) * config.rotationSpeed * 0.15;
      }

      renderer.render(scene, camera);
    }

    animate();

    // Watch for mode changes to update color
    const colorProp = container.dataset.color || 'auto';
    if (colorProp === 'auto') {
      const modeObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'data-mode') {
            const newColor = getBodyColor(container);
            (material.uniforms.color.value as THREE.Color).set(newColor);
          }
        });
      });

      modeObserver.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-mode'],
      });

      (container as any)._modeObserver = modeObserver;
    }

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width > 0 && height > 0) {
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        }
      }
    });
    resizeObserver.observe(container);

    const mutationObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((node) => {
          if (node === container || (node as Element).contains?.(container)) {
            cancelAnimationFrame(animationId);
            resizeObserver.disconnect();
            mutationObserver.disconnect();
            if ((container as any)._modeObserver) {
              (container as any)._modeObserver.disconnect();
            }
            geometry.dispose();
            material.dispose();
            renderer.dispose();
          }
        });
      });
    });

    if (container.parentElement) {
      mutationObserver.observe(container.parentElement, { childList: true });
    }
  }

  // Initialize all human-body flares on the page
  function initAll() {
    document.querySelectorAll('.human-body-container').forEach((container) => {
      const el = container as HTMLElement;
      if (el.dataset.initialized === 'true') return;
      el.dataset.initialized = 'true';
      initHumanBody(el);
    });
  }

  document.addEventListener('DOMContentLoaded', initAll);
  document.addEventListener('astro:page-load', initAll);
</script>
