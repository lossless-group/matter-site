---
/**
 * ImageAbstract--HumanBody--Particles
 *
 * A Three.js particle field creating a realistic human upper-body silhouette
 * with artistic particle distribution matching the reference image style.
 *
 * Design:
 * - Anatomically-inspired silhouette with organic curves
 * - Very dense, bright particles at the head (glowing effect)
 * - Gradual density falloff toward the torso
 * - Realistic shoulder/clavicle contours
 * - Subtle 3D depth with particle size/opacity variation
 */

interface Props {
  /** Container size in pixels or CSS units */
  size?: string;
  /** Particle color - can be hex, CSS variable name, or 'auto' to use --fx-orb-color */
  color?: string;
  /** Enable animation */
  animate?: boolean;
  /** Rotation speed multiplier */
  rotationSpeed?: number;
  /** Additional CSS classes */
  class?: string;
}

const {
  size = '520px',
  color = 'auto',
  animate = true,
  rotationSpeed = 0.15,
  class: className = '',
} = Astro.props as Props;

const containerId = `human-body-${Math.random().toString(36).slice(2, 9)}`;
---

<div
  id={containerId}
  class:list={['human-body-container', className]}
  style={`width: ${size}; height: ${size};`}
  data-color={color}
  data-animate={animate}
  data-rotation-speed={rotationSpeed}
>
  <canvas class="human-body-canvas"></canvas>
</div>

<style>
  .human-body-container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
  }

  .human-body-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<script>
  import * as THREE from 'three';

  interface HumanBodyConfig {
    color: string;
    animate: boolean;
    rotationSpeed: number;
  }

  /**
   * Get color - either from explicit prop or from CSS variable
   */
  function getBodyColor(container: HTMLElement): string {
    const colorProp = container.dataset.color || 'auto';

    if (colorProp === 'auto') {
      const computedStyle = getComputedStyle(document.documentElement);
      const cssColor = computedStyle.getPropertyValue('--fx-orb-color').trim();
      return cssColor || '#ffffff';
    }

    return colorProp;
  }

  function initHumanBody(container: HTMLElement) {
    const canvas = container.querySelector('.human-body-canvas') as HTMLCanvasElement | null;
    if (!canvas) return;

    const config: HumanBodyConfig = {
      color: getBodyColor(container),
      animate: container.dataset.animate !== 'false',
      rotationSpeed: parseFloat(container.dataset.rotationSpeed || '0.15'),
    };

    const scene = new THREE.Scene();

    const width = container.clientWidth || 400;
    const height = container.clientHeight || 400;

    const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 1000);
    camera.position.z = 3.2;

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    // Much higher particle count for dense, detailed appearance
    const particleCount = 25000;
    const positions = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);
    const alphas = new Float32Array(particleCount);

    let count = 0;

    /**
     * Sophisticated body silhouette using spline-like width functions
     * for organic, anatomically-inspired curves.
     * Coordinate system: x in [-1, 1], y in [0, 1] (bottom to top)
     */
    function getBodyWidth(y: number): number {
      // Head (y: 0.72 - 1.0)
      if (y >= 0.72) {
        const headY = (y - 0.72) / 0.28; // 0 at bottom of head, 1 at top
        // Egg-shaped head: wider at top-middle, tapering at chin and crown
        const headWidth = 0.16 * Math.sqrt(1 - Math.pow(headY * 2 - 1, 2) * 0.85);
        // Slight taper toward chin
        if (headY < 0.3) {
          return headWidth * (0.7 + headY);
        }
        return headWidth;
      }

      // Neck (y: 0.67 - 0.72) - shorter, thicker neck
      if (y >= 0.67) {
        const neckT = (y - 0.67) / 0.05;
        // Neck widens toward head
        return 0.09 + neckT * 0.03;
      }

      // Trapezius / upper shoulder slope (y: 0.52 - 0.67)
      if (y >= 0.52) {
        const trapT = (y - 0.52) / 0.15;
        // Smooth transition from broad shoulders to thicker neck
        const neckWidth = 0.09;
        const shoulderWidth = 0.38;
        // Use smoothstep for organic transition
        const t = trapT * trapT * (3 - 2 * trapT);
        return shoulderWidth + (neckWidth - shoulderWidth) * t;
      }

      // Shoulders / deltoids (y: 0.44 - 0.52)
      if (y >= 0.44) {
        const shoulderT = (y - 0.44) / 0.08;
        // Shoulders curve downward at edges
        const baseWidth = 0.38 - shoulderT * 0.02;
        return baseWidth;
      }

      // Upper chest / pectorals (y: 0.32 - 0.44)
      if (y >= 0.32) {
        const chestT = (y - 0.32) / 0.12;
        // Slight chest curve
        return 0.32 - chestT * 0.04;
      }

      // Mid torso (y: 0.18 - 0.32)
      if (y >= 0.18) {
        const midT = (y - 0.18) / 0.14;
        // Taper toward waist
        return 0.26 - midT * 0.06;
      }

      // Lower torso / waist (y: 0.0 - 0.18)
      const lowerT = y / 0.18;
      // Gradual fade-out at bottom
      return 0.20 * lowerT;
    }

    /**
     * Check if point is inside body silhouette with edge softness
     */
    function inBody(x: number, y: number): { inside: boolean; edgeDist: number } {
      const width = getBodyWidth(y);
      const absX = Math.abs(x);

      if (absX > width) {
        return { inside: false, edgeDist: 0 };
      }

      // Calculate distance from edge (0 = at edge, 1 = at center)
      const edgeDist = 1 - (absX / width);
      return { inside: true, edgeDist };
    }

    /**
     * Add anatomical detail: shoulder curve indentation
     */
    function shoulderCurveAdjustment(x: number, y: number): number {
      // Create the deltoid/arm cutout curve on each side
      if (y >= 0.35 && y <= 0.52) {
        const absX = Math.abs(x);
        if (absX > 0.28) {
          // Curve inward at the outer shoulders
          const t = (y - 0.35) / 0.17;
          const curveDepth = 0.08 * Math.sin(t * Math.PI);
          if (absX > 0.38 - curveDepth) {
            return -1; // Outside
          }
        }
      }
      return 0;
    }

    const maxTries = particleCount * 8;
    let tries = 0;

    while (count < particleCount && tries < maxTries) {
      tries++;

      // Sample in body bounds
      const x = (Math.random() - 0.5) * 0.9;
      const y = Math.random();

      const bodyCheck = inBody(x, y);
      if (!bodyCheck.inside) continue;

      // Check shoulder curve adjustment
      if (shoulderCurveAdjustment(x, y) < 0) continue;

      // Density varies by region
      let density = 0.5;

      // Head is VERY dense (like the reference image's glowing head)
      if (y >= 0.72) {
        density = 1.0;
      }
      // Upper body moderately dense
      else if (y >= 0.45) {
        density = 0.4 + (y - 0.45) * 1.5;
      }
      // Lower body sparser
      else {
        density = 0.15 + y * 0.5;
      }

      // Edge particles are sparser for soft silhouette edge
      density *= 0.3 + bodyCheck.edgeDist * 0.7;

      if (Math.random() > density) continue;

      // Map to 3D coordinates
      const px = x * 2.5;
      const py = (y - 0.55) * 2.8; // Center vertically

      // Z depth: more depth in torso, flatter head
      let zRange = 0.15;
      if (y >= 0.72) {
        zRange = 0.25; // Head has more 3D roundness
      } else if (y >= 0.45) {
        zRange = 0.20;
      }
      const pz = (Math.random() - 0.5) * zRange;

      const baseIndex = count * 3;
      positions[baseIndex] = px;
      positions[baseIndex + 1] = py;
      positions[baseIndex + 2] = pz;

      // Size varies: larger/brighter in head, smaller scattered in torso
      // Increased base sizes for more visual punch
      let sizeBase = 0.014 + Math.random() * 0.012;

      if (y >= 0.72) {
        // Head particles: dense, varied sizes for that "glowing" look
        sizeBase = 0.012 + Math.random() * 0.018;
        // Some larger "star" particles
        if (Math.random() < 0.2) {
          sizeBase *= 1.6;
        }
      } else if (y >= 0.5) {
        sizeBase = 0.013 + Math.random() * 0.014;
      } else {
        // Lower torso: sparser, more varied
        sizeBase = 0.010 + Math.random() * 0.016;
        if (Math.random() < 0.12) {
          sizeBase *= 2.0;
        }
      }

      sizes[count] = sizeBase;

      // Alpha varies for depth and glow effect
      let alpha = 0.6 + Math.random() * 0.4;
      if (y >= 0.72) {
        // Head is brighter
        alpha = 0.8 + Math.random() * 0.2;
      }
      // Fade edges
      alpha *= 0.5 + bodyCheck.edgeDist * 0.5;

      alphas[count] = alpha;
      count++;
    }

    const posTrimmed = positions.subarray(0, count * 3);
    const sizeTrimmed = sizes.subarray(0, count);
    const alphaTrimmed = alphas.subarray(0, count);

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(posTrimmed, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizeTrimmed, 1));
    geometry.setAttribute('alpha', new THREE.BufferAttribute(alphaTrimmed, 1));

    const material = new THREE.ShaderMaterial({
      uniforms: {
        color: { value: new THREE.Color(config.color) },
      },
      vertexShader: `
        attribute float size;
        attribute float alpha;
        varying float vAlpha;
        varying float vSize;

        void main() {
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          // Size attenuation - larger multiplier for bolder particles
          gl_PointSize = size * 500.0 * (1.0 / -mvPosition.z);

          // Pass alpha with depth-based adjustment
          float depthFade = smoothstep(5.0, 2.0, -mvPosition.z);
          vAlpha = alpha * depthFade;
          vSize = size;
        }
      `,
      fragmentShader: `
        uniform vec3 color;
        varying float vAlpha;
        varying float vSize;

        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);

          // Soft circular particle with glow
          float coreFalloff = 1.0 - smoothstep(0.0, 0.35, dist);
          float glowFalloff = 1.0 - smoothstep(0.2, 0.5, dist);

          float alpha = mix(glowFalloff * 0.6, coreFalloff, 0.7);
          alpha *= vAlpha;

          if (alpha < 0.005) discard;

          // Slight color boost in center for glow
          vec3 finalColor = color * (0.9 + coreFalloff * 0.3);

          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    let animationId: number;
    let time = 0;

    function animate() {
      animationId = requestAnimationFrame(animate);

      if (config.animate) {
        time += 0.016;
        // Very subtle, slow oscillation
        points.rotation.y = Math.sin(time * 0.15) * config.rotationSpeed * 0.4;
        points.rotation.x = Math.sin(time * 0.1) * config.rotationSpeed * 0.15;
      }

      renderer.render(scene, camera);
    }

    animate();

    // Watch for mode changes to update color
    const colorProp = container.dataset.color || 'auto';
    if (colorProp === 'auto') {
      const modeObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'data-mode') {
            const newColor = getBodyColor(container);
            (material.uniforms.color.value as THREE.Color).set(newColor);
          }
        });
      });

      modeObserver.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-mode'],
      });

      (container as any)._modeObserver = modeObserver;
    }

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width > 0 && height > 0) {
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        }
      }
    });
    resizeObserver.observe(container);

    const mutationObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((node) => {
          if (node === container || (node as Element).contains?.(container)) {
            cancelAnimationFrame(animationId);
            resizeObserver.disconnect();
            mutationObserver.disconnect();
            if ((container as any)._modeObserver) {
              (container as any)._modeObserver.disconnect();
            }
            geometry.dispose();
            material.dispose();
            renderer.dispose();
          }
        });
      });
    });

    if (container.parentElement) {
      mutationObserver.observe(container.parentElement, { childList: true });
    }
  }

  // Initialize all human-body flares on the page
  function initAll() {
    document.querySelectorAll('.human-body-container').forEach((container) => {
      const el = container as HTMLElement;
      if (el.dataset.initialized === 'true') return;
      el.dataset.initialized = 'true';
      initHumanBody(el);
    });
  }

  document.addEventListener('DOMContentLoaded', initAll);
  document.addEventListener('astro:page-load', initAll);
</script>
