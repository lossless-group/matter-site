---
/**
 * ImageAbstract--Orb
 *
 * A Three.js particle sphere with:
 * - Dense dot distribution creating a globe/sphere effect
 * - Central void/eye cutout (almond/lens shape)
 * - Varying density (denser at poles)
 * - Subtle rotation animation
 *
 * Based on brand design asset.
 */

interface Props {
  /** Container size in pixels or CSS units */
  size?: string;
  /** Particle color - can be hex, CSS variable name, or 'auto' to use --fx-orb-color */
  color?: string;
  /** Enable rotation animation */
  animate?: boolean;
  /** Rotation speed multiplier */
  rotationSpeed?: number;
  /** Additional CSS classes */
  class?: string;
}

const {
  size = '500px',
  color = 'auto', // 'auto' means use --fx-orb-color CSS variable (mode-aware)
  animate = true,
  rotationSpeed = 0.3,
  class: className = '',
} = Astro.props;

const containerId = `orb-${Math.random().toString(36).slice(2, 9)}`;
---

<div
  id={containerId}
  class:list={['orb-container', className]}
  style={`width: ${size}; height: ${size};`}
  data-color={color}
  data-animate={animate}
  data-rotation-speed={rotationSpeed}
>
  <canvas class="orb-canvas"></canvas>
</div>

<style>
  .orb-container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
  }

  .orb-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<script>
  import * as THREE from 'three';

  interface OrbConfig {
    color: string;
    animate: boolean;
    rotationSpeed: number;
  }

  /**
   * Get the orb color - either from explicit prop or from CSS variable
   */
  function getOrbColor(container: HTMLElement): string {
    const colorProp = container.dataset.color || 'auto';

    if (colorProp === 'auto') {
      // Read from CSS variable --fx-orb-color
      const computedStyle = getComputedStyle(document.documentElement);
      const cssColor = computedStyle.getPropertyValue('--fx-orb-color').trim();
      return cssColor || '#ffffff';
    }

    return colorProp;
  }

  // Store cleanup functions for each container
  const cleanupMap = new WeakMap<HTMLElement, () => void>();

  function initOrbWithCleanup(container: HTMLElement) {
    // If already has a cleanup function, it's already initialized
    if (cleanupMap.has(container)) return;

    const canvas = container.querySelector('.orb-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    // Get configuration from data attributes
    const config: OrbConfig = {
      color: getOrbColor(container),
      animate: container.dataset.animate !== 'false',
      rotationSpeed: parseFloat(container.dataset.rotationSpeed || '0.3'),
    };

    // Scene setup
    const scene = new THREE.Scene();
    const width = container.clientWidth;
    const height = container.clientHeight;

    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.z = 3;

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    // Create particle geometry
    const particleCount = 8000;
    const positions = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);

    const radius = 1;
    let particleIndex = 0;

    for (let i = 0; i < particleCount * 3; i++) {
      const goldenRatio = (1 + Math.sqrt(5)) / 2;
      const idx = i / 3;
      const phi = Math.acos(1 - (2 * (idx + 0.5)) / particleCount);
      const theta = (2 * Math.PI * idx) / goldenRatio;

      let x = radius * Math.sin(phi) * Math.cos(theta);
      let y = radius * Math.sin(phi) * Math.sin(theta);
      let z = radius * Math.cos(phi);

      const distFromCenter = Math.sqrt(y * y + z * z);
      const eyeWidth = 0.35;
      const eyeHeight = 0.5;
      const eyeTest = (Math.abs(x) / eyeWidth) + (distFromCenter / eyeHeight);
      const isInEye = eyeTest < 0.8 && Math.abs(x) < eyeWidth * 0.7;

      if (isInEye) continue;

      const polarDensityBoost = Math.pow(Math.abs(Math.cos(phi)), 0.3);
      if (Math.random() > 0.3 + polarDensityBoost * 0.5) continue;

      const noise = 0.015;
      x += (Math.random() - 0.5) * noise;
      y += (Math.random() - 0.5) * noise;
      z += (Math.random() - 0.5) * noise;

      if (particleIndex * 3 + 2 < particleCount * 3) {
        positions[particleIndex * 3] = x;
        positions[particleIndex * 3 + 1] = y;
        positions[particleIndex * 3 + 2] = z;
        sizes[particleIndex] = 0.015 + Math.random() * 0.01;
        particleIndex++;
      }
    }

    const actualPositions = positions.slice(0, particleIndex * 3);
    const actualSizes = sizes.slice(0, particleIndex);

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(actualPositions, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(actualSizes, 1));

    const material = new THREE.ShaderMaterial({
      uniforms: {
        color: { value: new THREE.Color(config.color) },
        pointSize: { value: 4.0 * window.devicePixelRatio },
      },
      vertexShader: `
        attribute float size;
        varying float vAlpha;
        void main() {
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * mvPosition;
          gl_PointSize = size * 300.0 * (1.0 / -mvPosition.z);
          vAlpha = smoothstep(3.5, 1.5, -mvPosition.z);
        }
      `,
      fragmentShader: `
        uniform vec3 color;
        varying float vAlpha;
        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);
          float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
          alpha *= vAlpha;
          if (alpha < 0.01) discard;
          gl_FragColor = vec4(color, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    let animationId: number;
    let time = 0;

    function animate() {
      animationId = requestAnimationFrame(animate);
      if (config.animate) {
        time += 0.016;
        particles.rotation.y = time * config.rotationSpeed * 0.5;
        particles.rotation.x = Math.sin(time * 0.2) * 0.1;
      }
      renderer.render(scene, camera);
    }

    animate();

    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width > 0 && height > 0) {
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        }
      }
    });
    resizeObserver.observe(container);

    // Mode observer for auto color
    let modeObserver: MutationObserver | null = null;
    const colorProp = container.dataset.color || 'auto';
    if (colorProp === 'auto') {
      modeObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'data-mode') {
            const newColor = getOrbColor(container);
            (material.uniforms.color.value as THREE.Color).set(newColor);
          }
        });
      });
      modeObserver.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-mode'],
      });
    }

    // Store cleanup function
    const cleanup = () => {
      cancelAnimationFrame(animationId);
      resizeObserver.disconnect();
      if (modeObserver) modeObserver.disconnect();
      geometry.dispose();
      material.dispose();
      renderer.dispose();
      renderer.forceContextLoss();
      cleanupMap.delete(container);
      container.dataset.initialized = '';
    };

    cleanupMap.set(container, cleanup);
    container.dataset.initialized = 'true';
  }

  function destroyOrb(container: HTMLElement) {
    const cleanup = cleanupMap.get(container);
    if (cleanup) cleanup();
  }

  // Lazy loading with IntersectionObserver
  function setupLazyLoading() {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const container = entry.target as HTMLElement;
          if (entry.isIntersecting) {
            // Initialize when visible
            initOrbWithCleanup(container);
          } else {
            // Destroy when not visible to free WebGL context
            destroyOrb(container);
          }
        });
      },
      {
        rootMargin: '100px', // Start loading slightly before visible
        threshold: 0,
      }
    );

    document.querySelectorAll('.orb-container').forEach((container) => {
      observer.observe(container);
    });

    return observer;
  }

  let lazyObserver: IntersectionObserver | null = null;

  document.addEventListener('DOMContentLoaded', () => {
    lazyObserver = setupLazyLoading();
  });

  document.addEventListener('astro:page-load', () => {
    if (lazyObserver) lazyObserver.disconnect();
    lazyObserver = setupLazyLoading();
  });
</script>
