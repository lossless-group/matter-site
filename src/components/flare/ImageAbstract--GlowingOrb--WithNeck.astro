---
/**
 * ImageAbstract--GlowingOrb--WithNeck
 *
 * A Three.js particle visualization featuring:
 * - A dense, glowing orb with ethereal blue glow
 * - Elegant neck silhouettes extending from the orb
 *
 * Supports multiple configurations:
 * - necks: 'bottom' | 'top' | 'both' - which direction(s) necks extend
 * - orientation: 'vertical' | 'horizontal' - overall orientation
 *
 * For just the orb without neck, use ImageAbstract--HumanBody--BackView.astro
 */

interface Props {
  /** Container size in CSS units */
  size?: string;
  /** Base particle color */
  color?: string;
  /** Glow color for the halo effect */
  glowColor?: string;
  /** Which necks to show: 'bottom', 'top', or 'both' */
  necks?: 'bottom' | 'top' | 'both';
  /** Orientation: 'vertical' (up/down) or 'horizontal' (left/right) */
  orientation?: 'vertical' | 'horizontal';
  /** Enable animation */
  animate?: boolean;
  /** Rotation speed (0 = no rotation) */
  rotationSpeed?: number;
  /** Additional CSS classes */
  class?: string;
}

const {
  size = '520px',
  color = '#e8f0ff',
  glowColor = '#4488ff',
  necks = 'both',
  orientation = 'vertical',
  animate = true,
  rotationSpeed = 0.05,
  class: className = '',
} = Astro.props as Props;

const containerId = `orb-neck-${Math.random().toString(36).slice(2, 9)}`;
---

<div
  id={containerId}
  class:list={['orb-neck-container', className]}
  style={`width: ${size}; height: ${size};`}
  data-color={color}
  data-glow-color={glowColor}
  data-necks={necks}
  data-orientation={orientation}
  data-animate={animate}
  data-rotation-speed={rotationSpeed}
>
  <canvas class="orb-neck-canvas"></canvas>
</div>

<style>
  .orb-neck-container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
  }

  .orb-neck-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<script>
  import * as THREE from 'three';

  interface Config {
    color: string;
    glowColor: string;
    necks: 'bottom' | 'top' | 'both';
    orientation: 'vertical' | 'horizontal';
    animate: boolean;
    rotationSpeed: number;
  }

  function initOrbNeck(container: HTMLElement) {
    const canvas = container.querySelector('.orb-neck-canvas') as HTMLCanvasElement | null;
    if (!canvas) return;

    const config: Config = {
      color: container.dataset.color || '#e8f0ff',
      glowColor: container.dataset.glowColor || '#4488ff',
      necks: (container.dataset.necks as 'bottom' | 'top' | 'both') || 'both',
      orientation: (container.dataset.orientation as 'vertical' | 'horizontal') || 'vertical',
      animate: container.dataset.animate !== 'false',
      rotationSpeed: parseFloat(container.dataset.rotationSpeed || '0.05'),
    };

    const scene = new THREE.Scene();

    const width = container.clientWidth || 400;
    const height = container.clientHeight || 400;

    const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 1000);
    camera.position.z = 4;

    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    const group = new THREE.Group();
    scene.add(group);

    // Orb parameters - centered at origin
    const orbRadius = 0.5;
    const orbCenterY = 0;

    // Neck parameters
    const neckLength = 0.8;
    const neckOrbRadius = 0.12; // Radius where neck meets orb
    const neckEndRadius = 0.06; // Radius at far end of neck

    // Particle arrays
    const positions: number[] = [];
    const sizes: number[] = [];
    const opacities: number[] = [];
    const phases: number[] = [];

    /**
     * Generate orb particles - ultra-dense glowing sphere
     */
    function generateOrb() {
      const orbParticles = 35000;

      for (let i = 0; i < orbParticles; i++) {
        // Spherical distribution with bias toward surface for glow
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        // Bias toward surface for that solid-core-with-glow look
        const rNorm = Math.pow(Math.random(), 0.3);
        const r = rNorm * orbRadius;

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = orbCenterY + r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions.push(x, y, z);

        // Size - larger at surface for glow effect
        const surfaceFactor = rNorm;
        const baseSize = 0.012 + surfaceFactor * 0.018;
        sizes.push(baseSize + Math.random() * 0.01);

        // Opacity - nearly solid at center, glowing at edges
        const centerOpacity = 0.95;
        const edgeOpacity = 0.7;
        const opacity = centerOpacity - (centerOpacity - edgeOpacity) * surfaceFactor;
        opacities.push(opacity + Math.random() * 0.05);

        // Phase for shimmer
        phases.push(Math.random() * Math.PI * 2);
      }
    }

    /**
     * Generate outer glow particles - sparse halo around orb
     */
    function generateOrbGlow() {
      const glowParticles = 8000;
      const glowRadius = orbRadius * 1.6;

      for (let i = 0; i < glowParticles; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        // Only in the glow shell region
        const rMin = orbRadius * 0.9;
        const rMax = glowRadius;
        const r = rMin + Math.random() * (rMax - rMin);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = orbCenterY + r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions.push(x, y, z);

        // Larger, more diffuse particles for glow
        sizes.push(0.02 + Math.random() * 0.025);

        // Fade out with distance from orb
        const distFromSurface = (r - orbRadius) / (glowRadius - orbRadius);
        const opacity = 0.4 * (1 - distFromSurface * distFromSurface);
        opacities.push(opacity);

        phases.push(Math.random() * Math.PI * 2);
      }
    }

    /**
     * Generate neck particles - elegant tapered column
     * @param direction - 1 for upward (top), -1 for downward (bottom)
     */
    function generateNeck(direction: number) {
      const neckParticles = 5000;
      const neckStartY = orbCenterY + direction * orbRadius * 0.85;

      for (let i = 0; i < neckParticles; i++) {
        // Position along neck (0 = near orb, 1 = far end)
        const t = Math.pow(Math.random(), 0.6); // Bias toward orb

        const y = neckStartY + direction * t * neckLength;

        // Radius tapers from orb to end
        const radius = neckOrbRadius * (1 - t) + neckEndRadius * t;

        // Random angle around neck
        const theta = Math.random() * Math.PI * 2;

        // Position within neck cylinder (bias toward surface)
        const rNorm = Math.pow(Math.random(), 0.5);
        const r = rNorm * radius;

        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);

        positions.push(x, y, z);

        // Size - slightly smaller than orb
        sizes.push(0.01 + Math.random() * 0.012);

        // Opacity - bright near orb, fading outward
        const orbOpacity = 0.75;
        const endOpacity = 0.15;
        const opacity = orbOpacity - (orbOpacity - endOpacity) * t;
        opacities.push(opacity * (0.8 + rNorm * 0.2));

        phases.push(Math.random() * Math.PI * 2);
      }
    }

    /**
     * Generate neck glow - subtle aura around neck
     * @param direction - 1 for upward (top), -1 for downward (bottom)
     */
    function generateNeckGlow(direction: number) {
      const glowParticles = 1200;
      const neckStartY = orbCenterY + direction * orbRadius * 0.85;

      for (let i = 0; i < glowParticles; i++) {
        const t = Math.random() * 0.7; // Only near-orb portion
        const y = neckStartY + direction * t * neckLength;

        const baseRadius = neckOrbRadius * (1 - t * 0.5);
        const glowExtent = baseRadius * 2.5;

        const theta = Math.random() * Math.PI * 2;
        const r = baseRadius + Math.random() * (glowExtent - baseRadius);

        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);

        positions.push(x, y, z);

        sizes.push(0.018 + Math.random() * 0.02);

        // Very dim glow
        const distFromNeck = (r - baseRadius) / (glowExtent - baseRadius);
        const opacity = 0.15 * (1 - distFromNeck);
        opacities.push(opacity);

        phases.push(Math.random() * Math.PI * 2);
      }
    }

    // Generate all particles
    generateOrb();
    generateOrbGlow();

    // Generate necks based on configuration
    if (config.necks === 'bottom' || config.necks === 'both') {
      generateNeck(-1);
      generateNeckGlow(-1);
    }
    if (config.necks === 'top' || config.necks === 'both') {
      generateNeck(1);
      generateNeckGlow(1);
    }

    // Apply orientation rotation
    if (config.orientation === 'horizontal') {
      group.rotation.z = Math.PI / 2;
    }

    // Create geometry
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('opacity', new THREE.Float32BufferAttribute(opacities, 1));
    geometry.setAttribute('phase', new THREE.Float32BufferAttribute(phases, 1));

    const particleColor = new THREE.Color(config.color);
    const glowCol = new THREE.Color(config.glowColor);

    // Custom shader for soft glowing particles
    const material = new THREE.ShaderMaterial({
      uniforms: {
        color: { value: particleColor },
        glowColor: { value: glowCol },
        time: { value: 0 },
      },
      vertexShader: `
        attribute float size;
        attribute float opacity;
        attribute float phase;

        varying float vOpacity;
        varying float vPhase;
        varying float vY;

        void main() {
          vOpacity = opacity;
          vPhase = phase;
          vY = position.y;

          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          gl_PointSize = size * 380.0 * (1.0 / -mvPosition.z);
          gl_PointSize = max(gl_PointSize, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 color;
        uniform vec3 glowColor;
        uniform float time;

        varying float vOpacity;
        varying float vPhase;
        varying float vY;

        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);

          // Soft circular falloff
          float coreFalloff = 1.0 - smoothstep(0.0, 0.3, dist);
          float glowFalloff = 1.0 - smoothstep(0.15, 0.5, dist);

          float alpha = mix(glowFalloff * 0.6, coreFalloff, 0.65);

          // Shimmer
          float shimmer = 0.88 + 0.12 * sin(time * 1.8 + vPhase * 8.0);
          alpha *= vOpacity * shimmer;

          if (alpha < 0.01) discard;

          // Blend white core with blue glow
          vec3 finalColor = mix(color, glowColor, 0.15);
          finalColor *= 1.1 + coreFalloff * 0.3;

          gl_FragColor = vec4(finalColor, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
    });

    const particles = new THREE.Points(geometry, material);
    group.add(particles);

    // Add a soft glow sphere behind the orb
    const glowSphereGeo = new THREE.SphereGeometry(orbRadius * 1.3, 32, 32);
    const glowSphereMat = new THREE.ShaderMaterial({
      uniforms: {
        glowColor: { value: glowCol },
        intensity: { value: 0.35 },
      },
      vertexShader: `
        varying vec3 vNormal;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 glowColor;
        uniform float intensity;
        varying vec3 vNormal;
        void main() {
          float rim = pow(0.65 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.5);
          gl_FragColor = vec4(glowColor, rim * intensity);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide,
    });
    const glowSphere = new THREE.Mesh(glowSphereGeo, glowSphereMat);
    glowSphere.position.set(0, 0, -0.1);
    group.add(glowSphere);

    // Animation
    let animationId: number;
    let time = 0;

    function animate() {
      animationId = requestAnimationFrame(animate);

      if (config.animate) {
        time += 0.016;

        material.uniforms.time.value = time;

        // Subtle rotation
        if (config.rotationSpeed > 0) {
          group.rotation.y = Math.sin(time * config.rotationSpeed * 0.5) * 0.25;
        }

        // Gentle floating
        group.position.y = Math.sin(time * 0.4) * 0.02;

        // Subtle breathing
        const breathe = 1 + Math.sin(time * 0.6) * 0.015;
        group.scale.setScalar(breathe);
      }

      renderer.render(scene, camera);
    }

    animate();

    // Resize handling
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        if (width > 0 && height > 0) {
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        }
      }
    });
    resizeObserver.observe(container);

    // Cleanup
    const mutationObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((node) => {
          if (node === container || (node as Element).contains?.(container)) {
            cancelAnimationFrame(animationId);
            resizeObserver.disconnect();
            mutationObserver.disconnect();
            geometry.dispose();
            material.dispose();
            glowSphereGeo.dispose();
            glowSphereMat.dispose();
            renderer.dispose();
          }
        });
      });
    });

    if (container.parentElement) {
      mutationObserver.observe(container.parentElement, { childList: true });
    }
  }

  // Lazy loading
  function setupLazyLoading() {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const container = entry.target as HTMLElement;
          if (entry.isIntersecting) {
            if (container.dataset.initialized !== 'true') {
              initOrbNeck(container);
              container.dataset.initialized = 'true';
            }
          }
        });
      },
      { rootMargin: '100px', threshold: 0 }
    );
    document.querySelectorAll('.orb-neck-container').forEach((c) => observer.observe(c));
    return observer;
  }

  let lazyObserver: IntersectionObserver | null = null;
  document.addEventListener('DOMContentLoaded', () => { lazyObserver = setupLazyLoading(); });
  document.addEventListener('astro:page-load', () => {
    if (lazyObserver) lazyObserver.disconnect();
    lazyObserver = setupLazyLoading();
  });
</script>
